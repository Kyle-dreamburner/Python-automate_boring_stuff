#-*-conding:utf-8-*-

# 1．创建 Regex 对象的函数是什么？
# re.compile()函数。向re.compile()传入一个字符串，他将返回一个Regex模式对象

#2．在创建 Regex 对象时，为什么常用原始字符串？
# 因为正则表达式中常常使用倒斜杠\来表示字符的格式。
# 而在Python中转义字符也使用倒斜杠(\)，所以使用原始字符串是为了
# 让反斜杠不必转义

#3． search()方法返回什么？
# 向Regex对象的search()方法传入想查找的字符串。返回一个Match对象。

#4．通过 Match 对象，如何得到匹配该模式的实际字符串？
# 调用Match对象的group()方法，返回实际匹配文本的字符串。

#5．用 r'(\d\d\d)-(\d\d\d-\d\d\d\d)'创建的正则表达式中，分组 0 表示什么？分组 1
#呢？分组 2 呢？
# 分组0和不分组，表示返回整个匹配的文本
# 分组1表示第1对括号的内容，即(\d\d\d)
# 分组2表示第2对括号的内容，即(\d\d\d-\d\d\d\d)

#6．括号和句点在正则表达式语法中有特殊的含义。如何指定正则表达式匹配真正的括号和句点字符？
# 要匹配真正的括号和句点，需使用\(\), \.

#7． findall()方法返回一个字符串的列表，或字符串元组的列表。是什么决定它
#提供哪种返回？
# 取决于正则表达式中是否有分组。如果正则表达式没有分组，则返回字符串列表
# 如果正则表达式有分组，则返回字符串元组的列表

#8．在正则表达式中， |字符表示什么意思？
# |字符被称为管道。相当于“或”的意思。如果希望匹配许多表达式中的一个，可以使用它。

# 9．在正则表达式中， ?字符有哪两种含义？
# 匹配这个问号前面的分组，零次或一次。
# 在用花括号进行匹配时，{3,5}? 表示非贪心模式，匹配尽可能最短的字符

#10．在正则表达式中， +和*字符之间的区别是什么？
# * 表示零次或多次。+ 表示一次或多次

#11．在正则表达式中， {3}和{3,5}之间的区别是什么？
# {3}匹配花括号前面的实例3次。{3,5}表示匹配前面的实例3|4|5次，
# 而且当实例满足要求时，会返回更长的结果，5次。

# 12．在正则表达式中， \d、 \w 和\s 缩写字符类是什么意思？
# \d 表示0到9的任何数字；\w 表示任何字母、数字或下划线字符（可以认为是匹配‘单词’字符）
# \s 空格、制表符或换行符（可以认为是匹配‘空白’字符）

#13．在正则表达式中， \D、 \W 和\S 缩写字符类是什么意思？
# \D 表示除0到9的数字以外的任何字符；\W 表示除字母、数字或下划线以外的任何字符；
# \S 除空格、制表符和换行符以外的任何字符

#14．如何让正则表达式不区分大小写？
# 向re.compile()传入re.IGNORECASE或re.I,作为第二参数。
# 如robocope = re.compile(r'robocop', re.I)

#15．字符.通常匹配什么？如果 re.DOTALL 作为第二个参数传递给 re.compile()，
#它会匹配什么？
# 字符.称为“通配符”。它匹配除了换行之外的所有字符。
# 如果将re.DOTALL作为第二个参数传递给re.compile(),他会匹配所有字符，包括换行字符。

#16． .*和*?之间的区别是什么？
# .*是匹配除换行符以外的所有的字符。 *? 是匹配零次和多次字符的非贪心用法。

#17．匹配所有数字和小写字母的字符分类语法是什么？
# [a-z0-9]

#18．如果 numRegex = re.compile(r'\d+')，那么 numRegex.sub('X', '12 drummers, 11
#pipers, five rings, 3 hens')返回什么？
# 返回'X drummers, X pipers, five rings, X hens'

#19．将 re.VERBOSE 作为第二个参数传递给 re.compile()，让你能做什么？
# 可以忽略正则表达式字符串中的空白符和注释。适合匹配复杂的文本模式，长的

#20． 如何写一个正则表达式， 匹配每 3 位就有一个逗号的数字？它必须匹配以
#下数字：
# '42'
# '1,234'
# '6,368,745'
#但不会匹配：
# '12,34,567' （逗号之间只有两位数字）
# '1234' （缺少逗号）
# numRegex = re.compile(r'(^\d{1,3}$|^\d{1,3}\,\d{3}$|^\d{1,3}\,(\d{3}\,)+\d{3}$)')

#21． 如何写一个正则表达式， 匹配姓 Nakamoto 的完整姓名？ 你可以假定名字
#总是出现在姓前面， 是一个大写字母开头的单词。该正则表达式必须匹配：
# 'Satoshi Nakamoto'
# 'Alice Nakamoto'
# 'RoboCop Nakamoto'
#但不匹配：
# 'satoshi Nakamoto'（名字没有大写首字母）
# 'Mr. Nakamoto'（前面的单词包含非字母字符）
# 'Nakamoto' （没有名字）
# 'Satoshi nakamoto'（姓没有首字母大写）

#nameRegex = re.compile(r'([A-Z]\w+\s[A-Z]\w+)')

#-*-coding:utf-8-*-
#22． 如何编写一个正则表达式匹配一个句子，它的第一个词是 Alice、 Bob 或
#Carol， 第二个词是 eats、 pets 或 throws， 第三个词是 apples、 cats 或 baseballs。该句
#子以句点结束。 这个正则表达式应该不区分大小写。它必须匹配：
# 'Alice eats apples.'
# 'Bob pets cats.'
# 'Carol throws baseballs.'
# 'Alice throws Apples.'
# 'BOB EATS CATS.'
#但不匹配：
# 'RoboCop eats apples.'
# 'ALICE THROWS FOOTBALLS.'
# 'Carol eats 7 cats.'

# sentenceRegex = re.compile(r'((Alice|Bob|Carol)\s(eats|pets|throws)\s(apples|cats|baseballs)\.)', re.I)
# mo = sentenceRegex.search('Carol throws baseballs.')
 
# print (mo.group())